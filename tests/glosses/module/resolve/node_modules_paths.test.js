const {
    module: { resolve }
} = ateos;
const path = require("path");
const parse = path.parse || require("path-parse");
const keys = require("object-keys");

const { nodeModulesPaths } = resolve;

const verifyDirs = function (start, dirs, moduleDirectories, paths) {
    const moduleDirs = [].concat(moduleDirectories || "node_modules");
    if (paths) {
        for (let k = 0; k < paths.length; ++k) {
            moduleDirs.push(path.basename(paths[k]));
        }
    }

    const foundModuleDirs = {};
    const uniqueDirs = {};
    const parsedDirs = {};
    for (let i = 0; i < dirs.length; ++i) {
        const parsed = parse(dirs[i]);
        if (!foundModuleDirs[parsed.base]) {
            foundModuleDirs[parsed.base] = 0;
        }
        foundModuleDirs[parsed.base] += 1;
        parsedDirs[parsed.dir] = true;
        uniqueDirs[dirs[i]] = true;
    }
    assert.equal(keys(parsedDirs).length >= start.split(path.sep).length, true, 'there are >= dirs than "start" has');
    const foundModuleDirNames = keys(foundModuleDirs);
    assert.deepEqual(foundModuleDirNames, moduleDirs, "all desired module dirs were found");
    assert.equal(keys(uniqueDirs).length, dirs.length, "all dirs provided were unique");

    const counts = {};
    for (let j = 0; j < foundModuleDirNames.length; ++j) {
        counts[foundModuleDirs[j]] = true;
    }
    assert.equal(keys(counts).length, 1, "all found module directories had the same count");
};

it("nodeModulesPaths()", () => {
    it("no options", () => {
        const start = path.join(__dirname, "resolver");
        const dirs = nodeModulesPaths(start);

        verifyDirs(start, dirs);
    });

    it("empty options", () => {
        const start = path.join(__dirname, "resolver");
        const dirs = nodeModulesPaths(start, {});

        verifyDirs(start, dirs);
    });

    it("with paths=array option", () => {
        const start = path.join(__dirname, "resolver");
        const paths = ["a", "b"];
        const dirs = nodeModulesPaths(start, { paths });

        verifyDirs(start, dirs, null, paths);
    });

    it("with paths=function option", () => {
        const paths = function paths(request, absoluteStart, getNodeModulesDirs, opts) {
            return getNodeModulesDirs().concat(path.join(absoluteStart, "not node modules", request));
        };

        const start = path.join(__dirname, "resolver");
        const dirs = nodeModulesPaths(start, { paths }, "pkg");

        verifyDirs(start, dirs, null, [path.join(start, "not node modules", "pkg")]);
    });

    it("with paths=function skipping node modules resolution", () => {
        const paths = function paths(request, absoluteStart, getNodeModulesDirs, opts) {
            return [];
        };
        const start = path.join(__dirname, "resolver");
        const dirs = nodeModulesPaths(start, { paths });
        assert.deepEqual(dirs, [], "no node_modules was computed");
    });

    it("with moduleDirectory option", () => {
        const start = path.join(__dirname, "resolver");
        const moduleDirectory = "not node modules";
        const dirs = nodeModulesPaths(start, { moduleDirectory });

        verifyDirs(start, dirs, moduleDirectory);
    });

    it("with 1 moduleDirectory and paths options", () => {
        const start = path.join(__dirname, "resolver");
        const paths = ["a", "b"];
        const moduleDirectory = "not node modules";
        const dirs = nodeModulesPaths(start, { paths, moduleDirectory });

        verifyDirs(start, dirs, moduleDirectory, paths);
    });

    it("with 1+ moduleDirectory and paths options", () => {
        const start = path.join(__dirname, "resolver");
        const paths = ["a", "b"];
        const moduleDirectories = ["not node modules", "other modules"];
        const dirs = nodeModulesPaths(start, { paths, moduleDirectory: moduleDirectories });

        verifyDirs(start, dirs, moduleDirectories, paths);
    });
});
